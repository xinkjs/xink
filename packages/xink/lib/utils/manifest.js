/** @import { Config } from '../types/internal.js' */

import { statSync } from 'node:fs'
import { join } from 'node:path'
import { readFiles } from './main.js'

/**
 * Generates the JavaScript code string for the virtual manifest module.
 *
 * @param {Config} config
 * @returns {Promise<string>} - Resolves with the JS code string.
 */
export const createManifestVirtualModule = async (config) => {
  const cwd = process.cwd()
  const { middleware_dir, params_dir, routes_dir } = config

  let importCounter = 0
  const importStatements = [] // Stores import strings: e.g., "import * as _mod0 from '...'"
  const routeEntries = [] // Stores { path: '/url/path', importName: '_mod0' }
  const paramMatcherEntries = {} // Stores { matcherType: '_mod1.match' }
  let middlewareHandlerRef = 'null' // Stores '_mod2.handle' or 'null'
  let errorHandlerRef = 'null' // Stores '_mod3.handleError' or 'null'
  let notFoundHandlerRef = 'null'

  const addImport = (filePath) => {
    // Ensure absolute path for Vite to resolve correctly
    const absolutePath = join(cwd, filePath)
    const importName = `_xink_mod_${importCounter++}`

    importStatements.push(`import * as ${importName} from '${absolutePath}';`)
    return importName
  }

  // --- Params ---
  try {
    statSync(join(cwd, params_dir)).isDirectory()
    for (const filePath of readFiles(params_dir, { extensions: ['js', 'ts'] })) {
      const type = filePath.split('.')[0].split('/').at(-1)
      const importName = addImport(filePath)
      // Assume the file exports 'match'
      paramMatcherEntries[type] = `${importName}.match`
    }
  } catch (err) { /* ignore if dir doesn't exist */ }

  // --- Middleware ---
  try {
    for (const filePath of readFiles(middleware_dir, { exact: true, filename: 'middleware', extensions: ['js', 'ts'] })) {
      const importName = addImport(filePath)
      // Assume the file exports 'handle'
      middlewareHandlerRef = `${importName}.handle`
      break
    }
  } catch (err) { /* ignore if dir doesn't exist */ }

  // --- Error Handling ---
  try {
    for (const filePath of readFiles('src', { exact: true, filename: 'error', extensions: ['js', 'ts'] })) {
      const importName = addImport(filePath)

      errorHandlerRef = `${importName}.handleError`
      notFoundHandlerRef = `${importName}.handleNotFound`
      break
    }
  } catch (err) { /* ignore if dir doesn't exist */ }

  // --- Routes ---
  try {
    statSync(join(cwd, routes_dir)).isDirectory()
  } catch (err) {
    throw new Error(`Routes directory ${routes_dir} does not exist.`)
  }

  for (let p of readFiles(routes_dir, { filename: 'route' })) {
    const relativePath = p.substring(routes_dir.length)
    const parts = relativePath.split('/')
    const dirs = parts.filter(t => !((/^route\.(?:js|ts|jsx|tsx)$/).test(t) || t === ''))
    let urlPath = dirs.length === 0 ? '/' : `/${dirs.join('/')}`

    // --- Convert path segments (same logic as original) ---
    urlPath = urlPath.replace(/\[{1}\.{3}([\w.~-]+?)\]{1}/g, '*$1') // Rest
    urlPath = urlPath.replace(/\[{1}([\w.~-]+?=[a-zA-Z]+?)\]{1}/g, ':$1') // Matchers
    urlPath = urlPath.replace(/\[{2}([\w.~-]+?)\]{2}/g, ':$1?') // Optionals
    urlPath = urlPath.replace(/\[{1}/g, ':') // Dynamics start
    urlPath = urlPath.replace(/\]{1}/g, '') // Dynamics end
    // --- End Path Conversion ---

    const importName = addImport(p) // Use original path 'p' relative to cwd

    routeEntries.push({
      path: urlPath,
      // Store the import name, the runtime will access handlers via this
      // e.g., _xink_mod_5.GET, _xink_mod_5.POST
      handlersModule: importName
    })
  }

  // --- Construct the final module string ---
  // Use JSON.stringify for paths, but keep handler/matcher references as code
  const manifestObjectString = `{
    routes: [
      ${routeEntries.map(r => `{ path: ${JSON.stringify(r.path)}, handlers: ${r.handlersModule} }`).join(',\n      ')}
    ],
    params: {
      ${Object.entries(paramMatcherEntries).map(([key, ref]) => `${JSON.stringify(key)}: ${ref}`).join(',\n      ')}
    },
    middleware: ${middlewareHandlerRef},
    error: ${errorHandlerRef},
    notfound: ${notFoundHandlerRef}
  }`

  const moduleCode = `
// --- Generated by vite-plugin-xink ---
${importStatements.join('\n')}

export const manifest = ${manifestObjectString};
`

  return moduleCode
}
